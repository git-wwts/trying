Testing the try script
===========================

try
---

try is a reserved word so we need a roundabout import
    >>> import imp
    >>> fp, pathname, description = imp.find_module('try')
    >>> try_module = imp.load_module('try', fp, pathname, description)

try.tests
---------

There is more text in here than I'd normally use in *.tests
But doctest got verbose when I called it *.test, showing:
    *** DocTestRunner.merge: 'try.test' in both testers; summing outcomes.

Assuming that this test is actually run under try
    otherwise the next line will crash

Running tests with try provides an instance called test
    which has some interesting attributes
    e.g. this file is called try.tests
    >>> test.path.name == 'try.tests'
    True

If that went well we have a hidden variable called test
    which is an object from the __main__ module
    and has some attributes

    >>> test.path_to_py.name == 'try.py'
    True

    >>> import os
    >>> assert test.here == os.getcwd()

We also have access to some modules I often use
    without a need for explicit import
    Which ignores the heuristic that
        "Explicit is better than implicit"
    >>> test.path.name == makepath(sys.argv[0]).name
    True

And we can run bash commands
    >>> bash('/bin/ls ~/.bashrc')
    /.../.bashrc
    True

    >>> assert test.home == makepath('~')

We know the user who is running the tests
    >>> assert test.user == '%s@%s' % (os.environ['USER'], test.host)

Edge cases
----------

    >>> bash('/bin/ls ~/no_such_file')
    FAIL: .../no_such_file: No such file or directory
    False

    >>> show(os)
    Help on module os:
    ...

    >>> show(0)
    0

    >>> test.add_path('fred', 'py')
    >>> 'fred' not in test.path_to_py
    True

    >>> sys.argv = ['try.py', '-r', test.path_to_tests]
    >>> options, args = try_module.command_line()
    Traceback (most recent call last):
    ...
    ValueError: Do not use --recursive with files (/.../try.tests)

    >>> sys.argv = ['try.py', '-v', test.path_to_tests]
    >>> options, args = try_module.command_line()
    >>> options.verbose and test.path_to_tests in args
    True

    >>> re_imported_try = try_module.make_module(test.path_to_py)
    >>> re_imported_try == try_module
    True

    >>> import see
    >>> see == try_module.make_module(test.path_to_py.parent / 'see.py')
    True
    >>> show(see)
    Help on module see:
    ...
        /.../testing/see.py
    ...

    >>> del sys.modules['see']
    >>> see = try_module.make_module(test.path_to_py.parent / 'see.py')
    >>> show(see)
    Help on module see:
    ...
        /.../testing/see.py
    ...
    >>> see = try_module.make_module(test.path_to_py.parent / 'not_a_file.py')
    Traceback (most recent call last):
    ...
    ImportError: Could not find a module for '/.../testing/not_a_file.py'

    >>> try_module.show_running_doctest(makepath('not_a_file.py'), options)
    Traceback (most recent call last):
    ...
    ImportError: Could not find a module for '.../not_a_file.py'

Hiding output
-------------

    >>> def hello(arg):
    ...     print('Hello')
    ...     return arg
    >>> hello('World')
    Hello
    'World'

    >>> no_print(hello, 'World')
    'World'
